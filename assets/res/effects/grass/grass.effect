// Effect Syntax Guide: https://github.com/cocos-creator/docs-3d/blob/master/zh/material-system/effect-syntax.md

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: vs:vert
      frag: fs:frag
      properties: &props
        alphaTest:      { value: 0.5 }

        windMap:        { value: black }
        windDirection: { value: [1, 1] }
        windSpeed: { value: 4 }
        windStrength: { value: 0.2 }
        windSwinging: { value: 0.17 }
        windRandObject: { value: 1 }
        windRandVertex: { value: 1 }
        windRandObjectStrength: { value: 0.709 }
        windGustStrength: { value: 0.196 }
        windGustFrequency: { value: 2.27 }
        windGustTint: { value: 2.27 }

        bendPushStrength: { value: 1 }
	      bendFlattenStrength: { value: 1 }
	      bendPerspectiveCorrection: { value: 1 }

        mainTexture:    { value: white, editor: { parent: USE_MAIN_TXTURE } }
        mainColor:      { value: [1, 1, 1, 1], editor: { type: color } }
        hueColor:       { value: [1, 1, 1, 1], editor: { type: color } }
        ambientOcclusion: { value: 0.704 }
        randomDarken: { value: 0.287 }

        specularHighlight: { value: 0 }
        translucency: { value: 1 }
        shadowIntensity: { value: 0.4 }
    - vert: shadow-caster-vs:vert
      frag: shadow-caster-fs:frag
      phase: shadow-add
      propertyIndex: 0
      rasterizerState:
        cullMode: back
  - name: transparent
    passes:
    - vert: vs:vert
      frag: fs:frag
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
    - vert: shadow-caster-vs:vert
      frag: shadow-caster-fs:frag
      phase: shadow-add
      propertyIndex: 0
      rasterizerState:
        cullMode: back
}%

CCProgram shared-ubos %{
  
  #if USE_MAIN_TXTURE
  uniform sampler2D mainTexture;
  #endif

  uniform Shared {
    vec4 mainColor;
    float alphaTest;
    float shadowIntensity;
  };

  #include <./wind>
  #include <./bend>
  #include <./color>

}%

CCProgram shared-funcs %{
  #include <cc-global>

  BendSettings getBendSettings (float mask) {
    BendSettings s;
    s.mode = 0;
    s.mask = mask;
    s.pushStrength = bendPushStrength;
	  s.flattenStrength = bendFlattenStrength;
	  s.perspectiveCorrection = bendPerspectiveCorrection;
    return s;
  }

  float randomRange (vec2 seed, float minv, float maxv) {
    float randomno = fract(sin(dot(seed, vec2(12.9898, 78.233)))*43758.5453);
    return mix(minv, maxv, randomno);
  }

  float objectPosRand01(mat4 mat) {
    return fract(mat[3][0] + mat[3][1] + mat[3][2]);
  }

  void calcGrassOffset (in vec4 lPos, inout vec4 wPos, float rand, vec3 colorAttr) {
    float mask = colorAttr.r;

    WindSettings w = getWinSettings(mask);
    vec4 windOffset = getWindOffset(lPos.xyz, wPos.xyz, rand, w, windMap);

    BendSettings b = getBendSettings(mask);
    vec4 bendOffset = getBendOffset(wPos.xyz, b);

    vec3 offsets = mix(windOffset.xyz, bendOffset.xyz, bendOffset.a).xyz;

    vec3 viewDirectionWS = normalize(cc_cameraPos.xyz - wPos.xyz);
    float NdotV = dot(vec3(0, 1, 0), viewDirectionWS);

    //Avoid pushing grass straight underneath the camera in a falloff of 4 units (1/0.25)
    float dist = clamp(distance(wPos.xz, cc_cameraPos.xz) * 0.25, 0., 1.);

    //Push grass away from camera position
    vec2 pushVec = -viewDirectionWS.xz;
    float perspMask = b.mask * b.perspectiveCorrection * dist * NdotV;
    offsets.xz += pushVec.xy * perspMask;
  
    //Apply bend offset
    wPos.xz += offsets.xz;
    wPos.y -= offsets.y;
  }

  vec4 calcGrassVertexColor(in vec4 lPos, in vec4 wPos, float rand, vec3 colorAttr) {
    return applyVertexColor(lPos.xyz, wPos.xyz, mainColor.xyz, colorAttr.r, ambientOcclusion, randomDarken, hueColor, rand);
  }
}%


CCProgram vs %{
  precision highp float;
  #include <input-standard>
  #include <cc-global>
  #include <cc-local-batch>
  #include <input-standard>
  #include <cc-fog>
  #include <cc-shadow-map-vs>

  #include <shared-ubos>
  #include <shared-funcs>

  in vec3 a_color;

  out vec3 v_wPos;
  // out vec3 v_normal;
  out vec3 v_tangent;
  out vec3 v_bitangent;
  out vec2 v_uv;
  out vec4 v_color;
  out float factor_fog;

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 lPos = In.position;
    vec4 wPos = matWorld * lPos;

    float rand = objectPosRand01(matWorld); // should be 0 - 1;
    calcGrassOffset(lPos, wPos, rand, a_color);

    v_color = calcGrassVertexColor(lPos, wPos, rand, a_color);

    // debug bend map
    // vec2 uv = getBendMapUV(wPos.xyz);
	  // v_color = texture(cc_grass_bend_map, uv);

    v_wPos = wPos.xyz;
    // v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);
    // v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
    // v_bitangent = cross(v_normal, v_tangent) * In.tangent.w; // note the cross order

    v_uv = a_texCoord;
    factor_fog = CC_TRANSFER_FOG(wPos);

    CCPassShadowParams(wPos);

    return cc_matProj * cc_matView * wPos;
  }

}%

CCProgram fs %{
  precision highp float;
  #include <output>
  #include <cc-fog>
  #include <gamma>

  #if CC_RECEIVE_SHADOW
    #include <cc-shadow-map-fs>
  #endif

  #include <shared-ubos>
  #include <shared-funcs>

  #include <./phong>

  in vec2 v_uv;
  in vec4 v_color;
  in float factor_fog;

  in vec3 v_wPos;
  // in vec3 v_normal;

  float getShadowAttenuation () {
    float shadowAttenuation = 0.0;

    #if CC_RECEIVE_SHADOW
      float pcf = cc_shadowInfo.x + 0.001;
      if (pcf > 3.0) {shadowAttenuation = CCGetShadowFactorX25();}
      else if (3.0 > pcf && pcf > 2.0) {shadowAttenuation = CCGetShadowFactorX9();}
      else if (2.0 > pcf && pcf > 1.0) {shadowAttenuation = CCGetShadowFactorX5();}
      else {shadowAttenuation = CCGetShadowFactorX1();}
    #endif

    return shadowAttenuation;
  }

  vec3 Translucency(vec3 viewDirectionWS, float amount, float shadowAttenuation) {
    vec3 ld = normalize(cc_mainLitDir.xyz);
    float VdotL = max(0., dot(viewDirectionWS, ld)) * amount;

    //TODO: Incorperate size parameter
    VdotL = pow(VdotL, 4.) * 8.;

    //Translucency masked by shadows and grass mesh bottom
    float tMask = VdotL * shadowAttenuation;// * light.distanceAttenuation;

    //Fade the effect out as the sun approaches the horizon (75 to 90 degrees)
    // float sunAngle = dot(vec3(0., 1., 0.), ld);
    // float angleMask = clamp(sunAngle * 6.666, 0., 1.); /* 1.0/0.15 = 6.666 */

    // tMask *= angleMask;

    return clamp(tMask * cc_mainLitColor.rgb * cc_mainLitColor.w, 0., 1.);
  }

  vec4 frag () {
    #if USE_MAIN_TXTURE
    vec4 col = texture(mainTexture, v_uv);
    #else
    vec4 col = vec4(1.);
    #endif

    float alpha = col.a;
    vec3 albedo = col.rgb;

    if (alpha < alphaTest) {
      discard;
    }

    // apply vertex color
    albedo *= v_color.rgb;

    // wind gust color
	  WindSettings wind = getWinSettings(v_color.r);
    wind.gustStrength = 1.;
    float gust = sampleGustMap(v_wPos, wind, windMap);
	  albedo += min(vec3(gust * 10. * v_color.a), windGustTint);

    // shadow
    float shadowAttenuation = getShadowAttenuation();
    shadowAttenuation = 1. - min(shadowAttenuation, shadowIntensity);

    // lighting
    vec3 viewDirection = normalize(cc_cameraPos.xyz - v_wPos);

    PhongSurface s;
    s.diffuse = albedo;
    s.specular = vec3(0.);
    s.emissive = vec3(0.);
    s.opacity = alpha;
    s.glossiness = 10.;
    s.position = v_wPos;
    // s.normal = v_normal;
	  s.normal = vec3(0.5, 0.5, 1);

    s.viewDirection = viewDirection;

    vec4 final = CCPhongShading(s);
    final.rgb = final.rgb * shadowAttenuation;

    // translucency
    vec3 transmissionColor = Translucency(viewDirection, translucency, shadowAttenuation);

	  final.rgb += BlendOverlay(transmissionColor * 2.0, final.rgb);

    final = CC_APPLY_FOG(final, factor_fog);

    return final;
  }
}%

CCProgram shadow-caster-vs %{
  precision highp float;
  #include <input-standard>
  #include <cc-local-batch>
  #include <cc-shadow>

  #include <shared-ubos>
  #include <shared-funcs>

  out vec2 v_uv;

  out vec2 v_clip_depth;

  in vec3 a_color;

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 lPos = In.position;
    vec4 wPos = matWorld * lPos;

    float rand = objectPosRand01(matWorld); // should be 0 - 1;
    calcGrassOffset(lPos, wPos, rand, a_color);


    vec4 clipPos = cc_matLightViewProj * wPos;

    v_uv = a_texCoord;

    v_clip_depth = clipPos.zw;

    return clipPos;
  }
}%

CCProgram shadow-caster-fs %{
  precision highp float;
  #include <packing>

  #include <shared-ubos>

  in vec2 v_uv;
  in vec2 v_clip_depth;


  vec4 frag () {
    #if USE_MAIN_TXTURE
    vec4 baseColor = texture(mainTexture, v_uv);
    #else
    vec4 baseColor = vec4(1.);
    #endif

    if (baseColor.a < alphaTest) discard;

    return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);
  }
}%
